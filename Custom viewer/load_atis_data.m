function td_data = load_atis_data(filename, flipX, flipY)
% td_data = load_atis_data(filename, flipX=0, flipY=0)
%
% Loads data from files generated by the StreamLogger consumer for any type
% of event. This function only read (t,x,y,p) and discard other fields (if
% any) of events.
% timestamps are in uS
% td_data is a structure containing the fields ts, x, y and p
%
% flipX, flipY allow to flip the image arround the X and Y axes. If these values
% are non zero, the corresponding dimension will be flipped considering its size
% to be the value contained in the 'flip' variable (i.e. X = flipX - X)
% (They defaults to 0 if non-specified)

if ~exist('flipX','var')
    flipX = 0;
end
if ~exist('flipY','var')
    flipY = 0;
end

f=fopen(filename);

% skip header lines
endOfHeader = 0;
numCommentLine = 0;
while (endOfHeader==0)
    bod = ftell(f);
    tline = fgets(f,256);
    if(tline(1)~='%')
        endOfHeader = 1;
    else
        numCommentLine = numCommentLine+1;
    end
end
fseek(f,bod,'bof');

if (numCommentLine>0) % Ensure compatibility with previous files.
    % Read event type
    evType = fread(f,1,'char');
    % Read event size
    evSize = fread(f,1,'char');
else
    evSize =8;
end

bof=ftell(f);

fseek(f,0,'eof');
numEvents=floor((ftell(f)-bof)/evSize);

% read data
fseek(f,bof,'bof'); % start just after header
allTs=uint32(fread(f,numEvents,'uint32',evSize-4,'l')); % ts are 4 bytes (uint32) skipping 4 bytes after each
fseek(f,bof+4,'bof'); % timestamps start 4 after bof
allAddr=uint32(fread(f,numEvents,'uint32',evSize-4,'l')); % addr are each 4 bytes (uint32) separated by 4 byte timestamps

fclose(f);

td_data.ts = double(allTs);

xmask = hex2dec('000001FF');
ymask = hex2dec('0001FE00');
polmask = hex2dec('00020000');
xshift=0; % bits to shift x to right
yshift=9; % bits to shift y to right
polshift=17; % bits to shift p to right

addr=abs(allAddr); % make sure nonnegative or an error will result from bitand (glitches can somehow result in negative addressses...)
td_data.x=double(bitshift(bitand(addr,xmask),-xshift)); % x addresses
td_data.y=double(bitshift(bitand(addr,ymask),-yshift)); % y addresses
td_data.p=-1+2*double(bitshift(bitand(addr,polmask),-polshift)); % 1 for ON, -1 for OFF

if (flipX > 0)
    td_data.x = flipX - td_data.x;
end

if (flipY > 0)
    td_data.y = flipY - td_data.y;
end

end
